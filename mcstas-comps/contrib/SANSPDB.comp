/*******************************************************************************
**McStas, neutron ray-tracing package
*         Copyright 1997-2003, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: SANSPDB
*
* %I
* Written by: Martin Cramer Pedersen (mcpe@nbi.dk) and S&oslash;ren Kynde (kynde@nbi.dk)
* Date: October 17, 2012
* Origin: KU-Science
*
* A sample describing a thin solution of proteins. This components must be compiled
* with the -lgsl and -lgslcblas flags (and possibly linked to the appropriate
* libraries).
*
* %D
* This components expands the formfactor amplitude of the protein on spherical
* harmonics and computes the scattering profile using these. The expansion is
* done on amino-acid level and does not take hydration layer into account.
* The component must have a valid .pdb-file as an argument.
*
* %P
* RhoSolvent: [AA]               Scattering length density of the buffer.
* Concentration: [mM]            Concentration of sample.
* AbsorptionCrosssection: [1/m]  Absorption cross section of the sample.
* xwidth: [m]                    Dimension of component in the x-direction.
* yheight: [m]                   Dimension of component in the y-direction.
* zdepth: [m]                    Dimension of component in the z-direction.
* SampleToDetectorDistance: [m]  Distance from sample to detector (for focusing the scattered neutrons).
* DetectorRadius: [m]            Radius of the detector (for focusing the scattered neutrons).
* PDBFilepath: []		Path to the file describing the high resolution structure of the protein.
*
* %E
*******************************************************************************/

DEFINE COMPONENT SANSPDB



SETTING PARAMETERS (RhoSolvent = 9.4e-14, Concentration = 0.01, AbsorptionCrosssection = 0.0,
    xwidth, yheight, zdepth, 
		    SampleToDetectorDistance, DetectorRadius,
    string PDBFilepath = "PDBfile.pdb")


DEPENDENCY " @GSLFLAGS@ "
NOACC


SHARE INHERIT SANSPDBFast
EXTEND %{
  void Protein_Beads_get_coords(BeadStruct Residue, double *x, double *y, double *z)
	{
    *x = Residue.x;
    *y = Residue.y;
    *z = Residue.z;
		}
%}

DECLARE
%{
  double Absorption;
  double NumberDensity;

  // Protein properties
  // cdouble Matrix[SANSPDBOrderOfHarmonics+1][SANSPDBOrderOfHarmonics+1];
  ProteinStruct Protein;
%}

INITIALIZE
%{
  // Rescale concentration into number of aggregates per m^3 times 10^-4
  NumberDensity = Concentration * 6.02214129e19;

  // Standard sample handling
  if (!xwidth || !yheight || !zdepth) {
    exit (fprintf (stderr, "SANSPDB: %s: ERROR: Sample has no volume - check parameters.\n", NAME_CURRENT_COMP));
  }

  // count the number of residues
  Absorption = AbsorptionCrosssection;
  Protein.NumberOfResidues = CountResidues (PDBFilepath);
  Protein.Beads = calloc (Protein.NumberOfResidues, sizeof (BeadStruct));
  if (Protein.Beads == NULL)
    exit (fprintf (stderr, "SANSPDB: %s: ERROR: memory allocation\n", NAME_CURRENT_COMP));

  // initialize the protein from the PDB
  ReadAminoPDB (PDBFilepath, &Protein);
  MPI_MASTER (printf ("SANSPDB: %s: Scattering from %s with %d residues\n", NAME_CURRENT_COMP, PDBFilepath, Protein.NumberOfResidues););
%}

TRACE
%{
  // Declarations
  double t0;
  double t1;
  double l_full;
  double l;
  double l1;
  double q;
  double Intensity;
  double Weight;
  double IntensityPart;
  double SolidAngle;
  double qx;
  double qy;
  double qz;
  double v;
  double dt;
  double vx_i;
  double vy_i;
  double vz_i;
  char Intersect = 0;
  double Slope;
  double Offset;
  int i, j, ResidueID;
  cdouble** Matrix = (cdouble**)matrix2d_new (sizeof (cdouble), SANSPDBOrderOfHarmonics + 1, SANSPDBOrderOfHarmonics + 1);

  // Computation
  Intersect = box_intersect (&t0, &t1, x, y, z, vx, vy, vz, xwidth, yheight, zdepth);

  if (Intersect) {

    if (t0 < 0.0) {
      fprintf (stderr, "SANSPDB %s: Photon already inside sample - absorbing...\n", NAME_CURRENT_COMP);
      ABSORB;
    }

    // Compute properties of neutron
    v = sqrt (pow (vx, 2) + pow (vy, 2) + pow (vz, 2));
    l_full = v * (t1 - t0);
    dt = rand01 () * (t1 - t0) + t0;
    PROP_DT (dt);
    l = v * (dt - t0);

    // Store properties of incoming neutron
    vx_i = vx;
    vy_i = vy;
    vz_i = vz;

    // Generate new direction of neutron
    randvec_target_circle (&vx, &vy, &vz, &SolidAngle, 0, 0, SampleToDetectorDistance, DetectorRadius);

    NORM (vx, vy, vz);

    vx *= v;
    vy *= v;
    vz *= v;

    // Compute q
    qx = V2K * (vx_i - vx);
    qy = V2K * (vy_i - vy);
    qz = V2K * (vz_i - vz);

    q = sqrt (pow (qx, 2) + pow (qy, 2) + pow (qz, 2));

    // Compute scattering for a given q-value
    // ResetMatrix(Matrix, SANSPDBOrderOfHarmonics);
    for (i = 0; i <= SANSPDBOrderOfHarmonics; ++i)
      for (j = 0; j <= SANSPDBOrderOfHarmonics; ++j)
        Matrix[i][j] = cplx (0, 0);

    for (ResidueID = 0; ResidueID < Protein.NumberOfResidues; ++ResidueID) {
      // ExpandStructure(Matrix, &Protein, ResidueID, qDummy, RhoSolvent);
      double Legendre[SANSPDBOrderOfHarmonics + 1];
      double Bessel[SANSPDBOrderOfHarmonics + 1];

      // Residue information
      BeadStruct Residue = Protein.Beads[ResidueID];
      const double Volume = Residue.Volume;
      const double DeltaRhoProtein = Residue.ScatteringLength - Volume * RhoSolvent;

      double X, Y, Z;
      Protein_Beads_get_coords (Residue, &X, &Y, &Z);
      X = (X * Protein.Beads[ResidueID].ScatteringLength - RhoSolvent * Volume * Protein.Beads[ResidueID].xv) / DeltaRhoProtein;

      Y = (Y * Protein.Beads[ResidueID].ScatteringLength - RhoSolvent * Volume * Protein.Beads[ResidueID].yv) / DeltaRhoProtein;

      Z = (Z * Protein.Beads[ResidueID].ScatteringLength - RhoSolvent * Volume * Protein.Beads[ResidueID].zv) / DeltaRhoProtein;

      // Convert bead position to spherical coordinates
      const double Radius = sqrt (pow (X, 2) + pow (Y, 2) + pow (Z, 2));
      const double Theta = acos (Z / Radius);
      const double C = acos (X / (Radius * sin (Theta))) * Sign (Y);

      // Expand protein structure on harmonics
      gsl_sf_bessel_jl_array (SANSPDBOrderOfHarmonics, q * Radius, Bessel);

      for (i = 0; i <= SANSPDBOrderOfHarmonics; ++i) {
        gsl_sf_legendre_sphPlm_array (SANSPDBOrderOfHarmonics, i, cos (Theta), &Legendre[i]);

        for (j = i; j <= SANSPDBOrderOfHarmonics; ++j) {
          Matrix[j][i] = cadd (Matrix[j][i],
                               rmul (sqrt (4.0 * PI) * DeltaRhoProtein * Bessel[j] * Legendre[j], cmul (cpow (cplx (0, 1), cplx (j, 0)), Polar (1.0, -i * C))));
        }
      }

    } // for ResidueID

    Intensity = 0;
    // ComputeIntensity(Matrix, SANSPDBOrderOfHarmonics);
    for (i = 0; i <= SANSPDBOrderOfHarmonics; ++i) {
      for (j = 0; j <= i; ++j) {
        Intensity += ((j > 0) + 1.0) * pow (cabs (Matrix[i][j]), 2);
      }
    }

    // Compute new weight
    l1 = v * t1;
    p *= l_full * SolidAngle / (4.0 * PI) * NumberDensity * Intensity * exp (-Absorption * (l + l1) / v);

    SCATTER;
  }
%}

MCDISPLAY
%{
  box (0, 0, 0, xwidth, yheight, zdepth, 0, 0, 1, 0);
%}

END
